#include <iostream>
#include "Matrix.cpp"
using namespace std;

// настройка гиперматретров нейросети
//int INPUT_DIM = 4;
//int OUT_DIM = 3;
//int H_DIM = 10;

matrix<double> x, W1, b1, W2, t1, t2, h1;

// алгоритм предсказывания
matrix<double> predict(matrix<double>& input) {
    t1 = input * W1 + b1;
    h1 = relu(t1);
    t2 = h1 * W2;
    matrix z = softmax(t2);
    return z;
}

int main() {
    /*
     * Веса нейронов уже найдены, тестируем функцию предсказывания, где правильным ответом служит Verginica.
     * x - служит как входные признаки
     * W - веса между слоями
     * t - вектор значений слоя
     * z - вектор вероятностей
     * Для более удобной формы необходимо спользовать линейные операции, для этого пришлось организовать свой тип данных - matrix
     * Закомментированные строчки показывают альтернативный вариант создания матрицы, через vector
     * Однако более удобно вписывать матрицу сразу в конструктор объекта класса matrix, что как раз здесь и реализовано
     */
//    vector <vector <double> > xv = {{7.9, 3.1, 7.5, 1.8}};
//    x.get_matrix(xv);
    // Вводные данные нейросети
    x = {7.9, 3.1, 7.5, 1.8};

//    vector <vector <double> > W1v = {
//            {0.33462099,  0.10068401,  0.20557238, -0.19043767,  0.40249301, -0.00925352,  0.00628916,  0.74784975,  0.25069956, -0.09290041},
//            {0.41689589,  0.93211640, -0.32300143, -0.13845456,  0.58598293, -0.29140373, -0.28473491,  0.48021000, -0.32318306, -0.34146461},
//            {-0.21927019, -0.76135162, -0.11721704,  0.92123373,  0.19501658,  0.00904006,  1.03040632, -0.66867859, -0.01571104, -0.08372566},
//            {-0.67791724,  0.07044558, -0.40981071,  0.62098450, -0.33009159, -0.47352435,  0.09687051, -0.68724299,  0.43823402, -0.26574543}
//    };
//    W1.get_matrix(W1v);

    W1 = {
            {0.33462099,  0.10068401,  0.20557238, -0.19043767,  0.40249301, -0.00925352,  0.00628916,  0.74784975,  0.25069956, -0.09290041},
            {0.41689589,  0.93211640, -0.32300143, -0.13845456,  0.58598293, -0.29140373, -0.28473491,  0.48021000, -0.32318306, -0.34146461},
            {-0.21927019, -0.76135162, -0.11721704,  0.92123373,  0.19501658,  0.00904006,  1.03040632, -0.66867859, -0.01571104, -0.08372566},
            {-0.67791724,  0.07044558, -0.40981071,  0.62098450, -0.33009159, -0.47352435,  0.09687051, -0.68724299,  0.43823402, -0.26574543}
    };

//    vector <vector <double> > b1v = {{-0.34133575, -0.24401602, -0.06262318, -0.30410971, -0.37097632,  0.02670964, -0.51851308,  0.54665141,  0.20777536, -0.29905165}};
//    b1.get_matrix(b1v);
    b1 = {-0.34133575, -0.24401602, -0.06262318, -0.30410971, -0.37097632,  0.02670964, -0.51851308,  0.54665141,  0.20777536, -0.29905165};


//    vector <vector <double> > W2v = {
//            {0.41186367,  0.15406952, -0.47391773},
//            {0.79701137, -0.64672799, -0.06339983},
//            {-0.20137522, -0.07088810,  0.00212071},
//            {-0.58743081, -0.17363843,  0.93769169},
//            {0.33262125,  0.18999841, -0.14977653},
//            {0.04450406,  0.26168097,  0.10104333},
//            {-0.74384144,  0.33092591,  0.65464737},
//            {0.45764631,  0.48877246, -1.16928700},
//            {-0.16020630, -0.12369116,  0.14171301},
//            {0.26099978,  0.12834471,  0.20866959}
//    };
//    W2.get_matrix(W2v);
    W2 = {
            {0.41186367,  0.15406952, -0.47391773},
            {0.79701137, -0.64672799, -0.06339983},
            {-0.20137522, -0.07088810,  0.00212071},
            {-0.58743081, -0.17363843,  0.93769169},
            {0.33262125,  0.18999841, -0.14977653},
            {0.04450406,  0.26168097,  0.10104333},
            {-0.74384144,  0.33092591,  0.65464737},
            {0.45764631,  0.48877246, -1.16928700},
            {-0.16020630, -0.12369116,  0.14171301},
            {0.26099978,  0.12834471,  0.20866959}
    };

//    vector <vector <double> > b2v = {{-0.16286677,  0.06680119, -0.03563594}};
//    b2.get_matrix(b2v);
    matrix b2 = {-0.16286677,  0.06680119, -0.03563594};

    matrix probs = predict(x);
    int pred_class = probs.argmax();
    string class_names[3] = {"Setosa", "Versicolor", "Virginica"};
    cout << "Predicted class: " << class_names[pred_class] << endl;

}